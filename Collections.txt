
Java collections refer to a collection of individual objects that are represented as a single unit. You can perform all operations such as searching, sorting, insertion, manipulation, deletion, etc., on Java collections just like you do it on data.

They are multiple types of collections in Java; ie:

1- Arraylist
2- LinkedList
3- HashMap etc

----------- Java Collections Framework (JCF) -------------
The Java Collections Framework is a unified architecture for representing and manipulating collections in Java. It provides a set of interfaces, implementations, and algorithms that make it easier to work with groups of objects.

----------- What is a Collection in Java? -----------
A Collection in Java is a container object that groups multiple elements into a single unit. It's part of the Java Collections Framework and represents a group of objects known as its elements.


=============================================================

------ 1. Iterable ------
 - Description: Iterable is the root interface in the Java Collections framework. It defines a single method, iterator(), which returns an Iterator object. 
   This allows collections to be iterated over.
 - Purpose: Provides a way to traverse elements in a collection without exposing its internal structure.
 - Usage: Any class that implements Iterable can be used in a for-each loop.

------- 2. Collection -------
 - Description: Collection is an interface that extends Iterable. It represents a group of objects, known as elements or items. 
   It provides methods for basic operations like adding, removing, and checking the size of the collection.
 - Key Methods:
   - add(E e): Adds an element to the collection.
   - remove(Object o): Removes a specific element from the collection.
   - size(): Returns the number of elements in the collection.
   - isEmpty(): Checks if the collection is empty.
 - Purpose: Serves as a common base for all collections in Java.

------- 3. List -------
 - Description: List is an ordered collection (also known as a sequence). It extends Collection and allows duplicate elements. 
   Each element in a List has an index, and elements can be accessed by their position.
 -Key Methods:
    - get(int index): Retrieves the element at a specific index.
    - set(int index, E element): Replaces the element at a specific index.
    - indexOf(Object o): Returns the index of the first occurrence of the specified element.
Purpose: Maintains the order of elements and supports random access.


------- 4. Queue -------
 - Description: Queue is a collection designed for holding elements prior to processing. 
  It typically follows the First-In-First-Out (FIFO) principle, but some implementations may use other ordering principles (e.g., priority queues).
 - Key Methods:
	- offer(E e): Inserts an element into the queue.
	- poll(): Retrieves and removes the head of the queue.
	- peek(): Retrieves, but does not remove, the head of the queue.
 - Purpose: Used for managing tasks or elements that need to be processed in a specific order.


------- 5. Set -------
 - Description: Set is a collection that cannot contain duplicate elements. It extends Collection and ensures that all elements are unique.
 - Key Methods:
   - add(E e): Adds an element to the set (if it doesn't already exist).
   - contains(Object o): Checks if the set contains a specific element.
 - Purpose: Ensures uniqueness of elements, useful for scenarios where duplicates are not allowed.

------- 6. ArrayList -------
 - Description: ArrayList is a resizable array implementation of the List interface. It provides dynamic arrays that can grow as needed.
 - Key Features:
   - Resizable Array: Automatically resizes when capacity is exceeded.
   - Random Access: Supports fast access to elements by index (O(1) time complexity).
   - Duplicates Allowed: Can contain duplicate elements.
 - Performance:
   - Addition/Removal: Adding/removing elements at the end is efficient (O(1) amortized), but adding/removing in the middle is slower (O(n)).
   - Access: Accessing elements by index is very fast (O(1)).

------- 7. LinkedList -------
 - Description: LinkedList is a doubly-linked list implementation of the List interface. It maintains a linked structure where each element points to the next and previous elements.
 - Key Features:
   - Doubly-Linked Structure: Each node contains references to the previous and next nodes.
   - Efficient Insertion/Deletion: Adding or removing elements at any position is fast (O(1) if you have a reference to the node).
   - Duplicates Allowed: Can contain duplicate elements.
 - Performance:
   - Addition/Removal: Fast at any position if you have a reference to the node.
   - Access: Slower than ArrayList for accessing elements by index (O(n)).

------- 8. PriorityQueue -------
 - Description: PriorityQueue is a queue implementation that orders elements based on their natural ordering (or a custom comparator). It is typically implemented as a heap data structure.
 - Key Features:
   - Heap-Based: Elements are ordered such that the highest-priority element is always at the front.
   - Insertion Order: Does not preserve the insertion order; elements are ordered based on priority.
 - Key Methods:
   - offer(E e): Inserts an element into the queue.
   - poll(): Retrieves and removes the highest-priority element.
   - peek(): Retrieves, but does not remove, the highest-priority element.
 - Purpose: Useful for scenarios where elements need to be processed in a specific order (e.g., scheduling tasks).

------- 9. HashSet -------
 - Description: HashSet is a hash table-based implementation of the Set interface. It uses a hash function to store elements, ensuring that all elements are unique.
 - Key Features:
   - Hash Table: Uses a hash function to store elements, providing fast lookup, insertion, and deletion.
   - Unordered: Does not maintain any specific order of elements.
   - Duplicates Not Allowed: All elements must be unique.
 - Performance:
   - Lookup/Insertion/Deletion: Typically O(1) average case, but can degrade to O(n) in the worst case if there are many hash collisions.
 - Purpose: Efficient for scenarios where uniqueness and fast lookup are required.